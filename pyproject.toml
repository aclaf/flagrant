[build-system]
requires = ["uv_build>=0.9.6,<0.10.0"]
build-backend = "uv_build"

[project]
name = "flagrant"
version = "0.1.0"
authors = [{ name = "Tony Burns", email = "tony@tonyburns.net" }]
description = "Command-line argument, option, and subcommand parsing."
readme = "README.md"
requires-python = ">=3.10"
classifiers = [
  "Development Status :: 2 - Pre-Alpha",
  "Environment :: Console",
  "Intended Audience :: Developers",
  "License :: OSI Approved :: MIT License",
  "Operating System :: OS Independent",
  "Programming Language :: Python",
  "Programming Language :: Python :: 3",
  "Programming Language :: Python :: 3 :: Only",
  "Programming Language :: Python :: 3.10",
  "Programming Language :: Python :: 3.11",
  "Programming Language :: Python :: 3.12",
  "Programming Language :: Python :: 3.13",
  "Programming Language :: Python :: 3.14",
  "Topic :: Software Development :: Libraries :: Python Modules",
  "Topic :: Terminals",
  "Topic :: Utilities",
  "Typing :: Typed",
]
dependencies = ["typing-extensions>=4.15.0"]

[dependency-groups]
dev = [
  "basedpyright>=1.32.1",
  "codespell>=2.4.1",
  "commitizen>=4.9.1",
  "hypothesis>=6.147.0",
  "import-linter>=2.6",
  "prek>=0.2.12",
  "pytest-cov>=7.0.0",
  "pytest-mock>=3.15.1",
  "pytest>=8.4.2",
  "ruff>=0.14.3",
  "yamllint>=1.37.1",
]
benchmarking = ["pytest-benchmark>=5.2.2"]
fuzzing = ["atheris>=2.3.0; python_version < '3.12'"]
mutation = ["mutmut>=3.3.1; python_version < '3.14'"]
profiling = ["memray>=1.19.1", "py-spy>=0.4.1"]
docs = [
  "djlint>=1.36.4",
  "mkdocs-git-authors-plugin>=0.10.0",
  "mkdocs-git-revision-date-localized-plugin>=1.5.0",
  "mkdocs-glightbox>=0.5.2",
  "mkdocs-material>=9.7.0",
  "mkdocs-rss-plugin>=1.17.7",
  "mkdocstrings[python]>=0.30.1",
]

[tool.basedpyright]
exclude = [
  "**/node_modules",
  "**/temp",
  "**/tmp",
  "**/plans",
  "**/reviews",
  "**/specs",
  "tests/unit/parser/test_parser.py",
]
include = ["src", "tests"]
pythonVersion = "3.10"
reportImportCycles = "error"

[tool.codespell]
skip = "uv.lock,htmlcov,tmp,pnpm-lock.yaml,docs,reviews"
ignore-words-list = "devlop"

[tool.commitizen]
name = "cz_conventional_commits"
version_provider = "pep621"
tag_format = "v$version"
major_version_zero = true
update_changelog_on_bump = true
pre_bump_hooks = ["uv sync --all-packages --all-groups --all-extras"]

[tool.pytest.ini_options]
addopts = [
  "--import-mode=importlib",
  "--tb",
  "short",
  "--ignore=tests/benchmarks",
]
pythonpath = ["src"]
filterwarnings = ["error"]
testpaths = ["tests"]
xfail_strict = true
markers = [
  "benchmark: mark a test as a benchmark test.",
  "fuzz: mark a test as a fuzz test.",
  "integration: mark a test as an integration test.",
  "properties: mark a test as a properties test.",
  "unit: mark a test as a unit test.",
]

[tool.coverage.run]
branch = true
source = ["src/flagrant"]
relative_files = true
omit = ["tests/*", "**/__pycache__/*", "**/site-packages/*"]

[tool.coverage.report]
exclude_lines = [
  "pragma: no cover",
  "def __repr__",
  "raise AssertionError",
  "raise NotImplementedError",
  "if __name__ == .__main__.:",
  "if TYPE_CHECKING:",
  "@abstractmethod",
  "@abc.abstractmethod",
]
precision = 2
show_missing = true
skip_covered = false

[tool.coverage.xml]
output = "coverage.xml"

[tool.coverage.html]
directory = "htmlcov"

[tool.hypothesis]
database = ".hypothesis/examples"
verbosity = "verbose"
max_examples = 100

[tool.mutmut]
paths_to_mutate = ["src/flagrant"]
tests_dir = "tests"
runner = "pytest"

[tool.importlinter]
root_package = "flagrant"

# Architectural layer contracts
# ==============================
# These contracts enforce the architectural boundaries between different layers
# of the flagrant package. The architecture follows a clean separation between
# foundation types, specifications, and parsing implementation.
#
# Package structure (from lowest to highest dependency):
#   0. Foundation: types, enums, constraints, exceptions (zero internal deps)
#   1. Configuration primitives: defaults, configuration
#   2. Specification: specification.* (defines command/option specs)
#   3. Parser: parser.* (implements parsing based on specs)
#
# Key principles:
# - Foundation modules have zero internal dependencies
# - Specifications are declarative and isolated from parser implementation
# - Parser depends on specifications, never the reverse
# - Each package's exceptions inherit from root exceptions

[[tool.importlinter.contracts]]
name = "Foundation layer must be independent"
type = "independence"
modules = [
  "flagrant.types",
  "flagrant.enums",
  "flagrant.constraints",
  "flagrant.exceptions",
]
# These foundation modules provide types, enums, patterns, and base exceptions.
# They must remain completely independent with zero internal dependencies to
# serve as the stable foundation for all other modules.

[[tool.importlinter.contracts]]
name = "Specification package must not import from parser"
type = "forbidden"
source_modules = ["flagrant.specification"]
forbidden_modules = [
  "flagrant.parser",
  "flagrant.configuration",
]
# Specifications are declarative definitions of commands and options. They must
# not depend on parser implementation or configuration to maintain clean separation
# between "what to parse" (specification) and "how to parse" (parser).

[[tool.importlinter.contracts]]
name = "Parser depends on specification, not vice versa"
type = "forbidden"
source_modules = ["flagrant.specification"]
forbidden_modules = ["flagrant.parser"]
# Parser imports from specification to know what to parse, but specifications
# must never import from parser. This ensures one-way dependency flow.

[[tool.importlinter.contracts]]
name = "Configuration layer boundaries"
type = "forbidden"
source_modules = ["flagrant.configuration"]
forbidden_modules = [
  "flagrant.parser",
  "flagrant.specification._arity",
  "flagrant.specification._command",
  "flagrant.specification._options",
  "flagrant.specification.helpers",
  "flagrant.specification.validations",
  "flagrant.specification.exceptions",
]
# Configuration can import from foundation (defaults, enums, exceptions) and
# specification enums for type hints, but should not depend on specification
# internals or parser implementation.

[[tool.importlinter.contracts]]
name = "Defaults can only import from foundation and specification enums"
type = "forbidden"
source_modules = ["flagrant.defaults"]
forbidden_modules = [
  "flagrant.configuration",
  "flagrant.parser",
  "flagrant.specification._arity",
  "flagrant.specification._command",
  "flagrant.specification._options",
  "flagrant.specification.helpers",
  "flagrant.specification.validations",
  "flagrant.specification.exceptions",
]
# Defaults provides default values for configuration. It can import foundation
# modules and specification enums, but should not depend on higher layers.

[[tool.importlinter.contracts]]
name = "Specification enums and arity are foundational"
type = "forbidden"
source_modules = [
  "flagrant.specification.enums",
  "flagrant.specification._arity",
]
forbidden_modules = [
  "flagrant.specification.exceptions",
  "flagrant.specification.helpers",
  "flagrant.specification.validations",
  "flagrant.specification._options",
  "flagrant.specification._command",
]
# Enums and arity are foundational types that should not depend on other
# specification modules.

[[tool.importlinter.contracts]]
name = "Specification helpers and exceptions layer"
type = "forbidden"
source_modules = [
  "flagrant.specification.helpers",
  "flagrant.specification.exceptions",
]
forbidden_modules = [
  "flagrant.specification.validations",
  "flagrant.specification._options",
  "flagrant.specification._command",
]
# Helpers and exceptions are utilities that validations, options, and commands use.

[[tool.importlinter.contracts]]
name = "Specification validations layer"
type = "forbidden"
source_modules = ["flagrant.specification.validations"]
forbidden_modules = [
  "flagrant.specification._options",
  "flagrant.specification._command",
]
# Validations are used by options and commands, not vice versa.

[[tool.importlinter.contracts]]
name = "Specification options layer"
type = "forbidden"
source_modules = ["flagrant.specification._options"]
forbidden_modules = ["flagrant.specification._command"]
# Options are used by commands, commands don't import options internals.

[[tool.importlinter.contracts]]
name = "Parser internal structure"
type = "forbidden"
source_modules = ["flagrant.parser._result", "flagrant.parser.exceptions"]
forbidden_modules = ["flagrant.parser._parser"]
# Parse result and exceptions are independent types that don't depend on the
# parser implementation. Only the parser implementation imports from them.

[[tool.importlinter.contracts]]
name = "Exception hierarchy enforcement"
type = "forbidden"
source_modules = ["flagrant.exceptions"]
forbidden_modules = [
  "flagrant.specification",
  "flagrant.parser",
  "flagrant.configuration",
  "flagrant.defaults",
]
# Base exceptions must not import from any other flagrant modules. Package-specific
# exceptions (specification.exceptions, parser.exceptions) inherit from base
# exceptions, never the reverse.

[tool.ruff]
extend-exclude = [
  "**/node_modules/**",
  "**/temp/**",
  "**/tmp/**",
  "**/plans/**",
  "**/reviews/**",
  "**/specs/**",
]
force-exclude = true
target-version = "py310"

[tool.ruff.format]
docstring-code-format = true

[tool.ruff.lint]
select = [
  "A",     # flake8-builtins
  "ARG",   # flake8-unused-arguments
  "ASYNC", # flake8-async
  "B",     # bugbear
  "BLE",   # flake8-blind-except
  "C4",    # flake8-comprehensions
  "D",     # pydocstyle
  "DTZ",   # flake8-datetimez
  "E",     # pycodestyle (error)
  "EM",    # flake8-errmsg
  "EXE",   # flake8-executable
  "F",     # pyflakes
  "FBT",   # flake8-boolean-trap
  "FURB",  # refurb
  "G",     # flake8-logging-format
  "I",     # isort
  "ICN",   # flake8-import-conventions
  "ISC",   # flake8-implicit-str-concat
  "LOG",   # flake8-logging
  "N",     # pep8-naming
  "PERF",  # Perflint
  "PGH",   # pygrep-hooks
  "PIE",   # flake8-pie
  "PL",    # pylint
  "PT",    # flake8-pytest-style
  "PTH",   # flake8-use-pathlib
  "PYI",   # flake8-pyi
  "RET",   # flake8-return
  "RUF",   # Ruff-specific rules
  "S",     # flake8-bandit
  "SIM",   # flake8-simplify
  "SLF",   # flake8-self
  "SLOT",  # flake8-slots
  "TC",    # flake8-type-checking
  "TD",    # flake8-todos
  "TID",   # flake8-tidy-imports
  "T10",   # flake8-debugger
  "T20",   # flake8-print
  "TRY",   # tryceratops
  "UP",    # pyupgrade
]
ignore = ["TD003"]
pydocstyle = { convention = "google" }

[tool.ruff.lint.isort]
combine-as-imports = true
extra-standard-library = ["typing_extensions"]
forced-separate = ["tests"]

[tool.ruff.lint.flake8-type-checking]
quote-annotations = true

[tool.ruff.lint.flake8-unused-arguments]
ignore-variadic-names = true

[tool.ruff.lint.per-file-ignores]
"**/tests/**" = ["D", "S101"]
"examples/**" = ["T201"]      # Allow print in examples
"scripts/**" = ["T201"]       # Allow print in scripts
